// Since: cosmos-sdk 0.46

// @generated by protoc-gen-es v2.2.3 with parameter "target=ts,json_types=true,import_extension=ts"
// @generated from file cosmos/group/v1/types.proto (package cosmos.group.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import { file_gogoproto_gogo } from "../../../gogoproto/gogo_pb.ts";
import type { Any, AnyJson, Duration, DurationJson, Timestamp, TimestampJson } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_any, file_google_protobuf_duration, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import { file_cosmos_proto_cosmos } from "../../../cosmos_proto/cosmos_pb.ts";
import { file_amino_amino } from "../../../amino/amino_pb.ts";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file cosmos/group/v1/types.proto.
 */
export const file_cosmos_group_v1_types: GenFile = /*@__PURE__*/
  fileDesc("Chtjb3Ntb3MvZ3JvdXAvdjEvdHlwZXMucHJvdG8SD2Nvc21vcy5ncm91cC52MSKSAQoGTWVtYmVyEikKB2FkZHJlc3MYASABKAlCGNK0LRRjb3Ntb3MuQWRkcmVzc1N0cmluZxIOCgZ3ZWlnaHQYAiABKAkSEAoIbWV0YWRhdGEYAyABKAkSOwoIYWRkZWRfYXQYBCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQg3I3h8AkN8fAajnsCoBIlwKDU1lbWJlclJlcXVlc3QSKQoHYWRkcmVzcxgBIAEoCUIY0rQtFGNvc21vcy5BZGRyZXNzU3RyaW5nEg4KBndlaWdodBgCIAEoCRIQCghtZXRhZGF0YRgDIAEoCSKwAQoXVGhyZXNob2xkRGVjaXNpb25Qb2xpY3kSEQoJdGhyZXNob2xkGAEgASgJEjcKB3dpbmRvd3MYAiABKAsyJi5jb3Ntb3MuZ3JvdXAudjEuRGVjaXNpb25Qb2xpY3lXaW5kb3dzOknKtC0eY29zbW9zLmdyb3VwLnYxLkRlY2lzaW9uUG9saWN5iuewKiJjb3Ntb3Mtc2RrL1RocmVzaG9sZERlY2lzaW9uUG9saWN5IrMBChhQZXJjZW50YWdlRGVjaXNpb25Qb2xpY3kSEgoKcGVyY2VudGFnZRgBIAEoCRI3Cgd3aW5kb3dzGAIgASgLMiYuY29zbW9zLmdyb3VwLnYxLkRlY2lzaW9uUG9saWN5V2luZG93czpKyrQtHmNvc21vcy5ncm91cC52MS5EZWNpc2lvblBvbGljeYrnsCojY29zbW9zLXNkay9QZXJjZW50YWdlRGVjaXNpb25Qb2xpY3kioAEKFURlY2lzaW9uUG9saWN5V2luZG93cxI/Cg12b3RpbmdfcGVyaW9kGAEgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uQg3I3h8AmN8fAajnsCoBEkYKFG1pbl9leGVjdXRpb25fcGVyaW9kGAIgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uQg3I3h8AmN8fAajnsCoBIrgBCglHcm91cEluZm8SCgoCaWQYASABKAQSJwoFYWRtaW4YAiABKAlCGNK0LRRjb3Ntb3MuQWRkcmVzc1N0cmluZxIQCghtZXRhZGF0YRgDIAEoCRIPCgd2ZXJzaW9uGAQgASgEEhQKDHRvdGFsX3dlaWdodBgFIAEoCRI9CgpjcmVhdGVkX2F0GAYgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEINyN4fAJDfHwGo57AqASJICgtHcm91cE1lbWJlchIQCghncm91cF9pZBgBIAEoBBInCgZtZW1iZXIYAiABKAsyFy5jb3Ntb3MuZ3JvdXAudjEuTWVtYmVyIrYCCg9Hcm91cFBvbGljeUluZm8SKQoHYWRkcmVzcxgBIAEoCUIY0rQtFGNvc21vcy5BZGRyZXNzU3RyaW5nEhAKCGdyb3VwX2lkGAIgASgEEicKBWFkbWluGAMgASgJQhjStC0UY29zbW9zLkFkZHJlc3NTdHJpbmcSEAoIbWV0YWRhdGEYBCABKAkSDwoHdmVyc2lvbhgFIAEoBBJRCg9kZWNpc2lvbl9wb2xpY3kYBiABKAsyFC5nb29nbGUucHJvdG9idWYuQW55QiLKtC0eY29zbW9zLmdyb3VwLnYxLkRlY2lzaW9uUG9saWN5Ej0KCmNyZWF0ZWRfYXQYByABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQg3I3h8AkN8fAajnsCoBOgiIoB8A6KAfASLOBAoIUHJvcG9zYWwSCgoCaWQYASABKAQSNgoUZ3JvdXBfcG9saWN5X2FkZHJlc3MYAiABKAlCGNK0LRRjb3Ntb3MuQWRkcmVzc1N0cmluZxIQCghtZXRhZGF0YRgDIAEoCRIrCglwcm9wb3NlcnMYBCADKAlCGNK0LRRjb3Ntb3MuQWRkcmVzc1N0cmluZxI+CgtzdWJtaXRfdGltZRgFIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCDcjeHwCQ3x8BqOewKgESFQoNZ3JvdXBfdmVyc2lvbhgGIAEoBBIcChRncm91cF9wb2xpY3lfdmVyc2lvbhgHIAEoBBIvCgZzdGF0dXMYCCABKA4yHy5jb3Ntb3MuZ3JvdXAudjEuUHJvcG9zYWxTdGF0dXMSQwoSZmluYWxfdGFsbHlfcmVzdWx0GAkgASgLMhwuY29zbW9zLmdyb3VwLnYxLlRhbGx5UmVzdWx0QgnI3h8AqOewKgESRAoRdm90aW5nX3BlcmlvZF9lbmQYCiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQg3I3h8AkN8fAajnsCoBEkAKD2V4ZWN1dG9yX3Jlc3VsdBgLIAEoDjInLmNvc21vcy5ncm91cC52MS5Qcm9wb3NhbEV4ZWN1dG9yUmVzdWx0EiYKCG1lc3NhZ2VzGAwgAygLMhQuZ29vZ2xlLnByb3RvYnVmLkFueRINCgV0aXRsZRgNIAEoCRIPCgdzdW1tYXJ5GA4gASgJOgSIoB8AImsKC1RhbGx5UmVzdWx0EhEKCXllc19jb3VudBgBIAEoCRIVCg1hYnN0YWluX2NvdW50GAIgASgJEhAKCG5vX2NvdW50GAMgASgJEhoKEm5vX3dpdGhfdmV0b19jb3VudBgEIAEoCToEiKAfACLDAQoEVm90ZRITCgtwcm9wb3NhbF9pZBgBIAEoBBInCgV2b3RlchgCIAEoCUIY0rQtFGNvc21vcy5BZGRyZXNzU3RyaW5nEisKBm9wdGlvbhgDIAEoDjIbLmNvc21vcy5ncm91cC52MS5Wb3RlT3B0aW9uEhAKCG1ldGFkYXRhGAQgASgJEj4KC3N1Ym1pdF90aW1lGAUgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEINyN4fAJDfHwGo57AqASqPAQoKVm90ZU9wdGlvbhIbChdWT1RFX09QVElPTl9VTlNQRUNJRklFRBAAEhMKD1ZPVEVfT1BUSU9OX1lFUxABEhcKE1ZPVEVfT1BUSU9OX0FCU1RBSU4QAhISCg5WT1RFX09QVElPTl9OTxADEhwKGFZPVEVfT1BUSU9OX05PX1dJVEhfVkVUTxAEGgSIox4AKs4BCg5Qcm9wb3NhbFN0YXR1cxIfChtQUk9QT1NBTF9TVEFUVVNfVU5TUEVDSUZJRUQQABIdChlQUk9QT1NBTF9TVEFUVVNfU1VCTUlUVEVEEAESHAoYUFJPUE9TQUxfU1RBVFVTX0FDQ0VQVEVEEAISHAoYUFJPUE9TQUxfU1RBVFVTX1JFSkVDVEVEEAMSGwoXUFJPUE9TQUxfU1RBVFVTX0FCT1JURUQQBBIdChlQUk9QT1NBTF9TVEFUVVNfV0lUSERSQVdOEAUaBIijHgAqugEKFlByb3Bvc2FsRXhlY3V0b3JSZXN1bHQSKAokUFJPUE9TQUxfRVhFQ1VUT1JfUkVTVUxUX1VOU1BFQ0lGSUVEEAASJAogUFJPUE9TQUxfRVhFQ1VUT1JfUkVTVUxUX05PVF9SVU4QARIkCiBQUk9QT1NBTF9FWEVDVVRPUl9SRVNVTFRfU1VDQ0VTUxACEiQKIFBST1BPU0FMX0VYRUNVVE9SX1JFU1VMVF9GQUlMVVJFEAMaBIijHgBCJlokZ2l0aHViLmNvbS9jb3Ntb3MvY29zbW9zLXNkay94L2dyb3VwYgZwcm90bzM", [file_gogoproto_gogo, file_google_protobuf_duration, file_google_protobuf_timestamp, file_cosmos_proto_cosmos, file_google_protobuf_any, file_amino_amino]);

/**
 * Member represents a group member with an account address,
 * non-zero weight, metadata and added_at timestamp.
 *
 * @generated from message cosmos.group.v1.Member
 */
export type Member = Message<"cosmos.group.v1.Member"> & {
  /**
   * address is the member's account address.
   *
   * @generated from field: string address = 1;
   */
  address: string;

  /**
   * weight is the member's voting weight that should be greater than 0.
   *
   * @generated from field: string weight = 2;
   */
  weight: string;

  /**
   * metadata is any arbitrary metadata attached to the member.
   *
   * @generated from field: string metadata = 3;
   */
  metadata: string;

  /**
   * added_at is a timestamp specifying when a member was added.
   *
   * @generated from field: google.protobuf.Timestamp added_at = 4;
   */
  addedAt?: Timestamp;
};

/**
 * Member represents a group member with an account address,
 * non-zero weight, metadata and added_at timestamp.
 *
 * @generated from message cosmos.group.v1.Member
 */
export type MemberJson = {
  /**
   * address is the member's account address.
   *
   * @generated from field: string address = 1;
   */
  address?: string;

  /**
   * weight is the member's voting weight that should be greater than 0.
   *
   * @generated from field: string weight = 2;
   */
  weight?: string;

  /**
   * metadata is any arbitrary metadata attached to the member.
   *
   * @generated from field: string metadata = 3;
   */
  metadata?: string;

  /**
   * added_at is a timestamp specifying when a member was added.
   *
   * @generated from field: google.protobuf.Timestamp added_at = 4;
   */
  addedAt?: TimestampJson;
};

/**
 * Describes the message cosmos.group.v1.Member.
 * Use `create(MemberSchema)` to create a new message.
 */
export const MemberSchema: GenMessage<Member, MemberJson> = /*@__PURE__*/
  messageDesc(file_cosmos_group_v1_types, 0);

/**
 * MemberRequest represents a group member to be used in Msg server requests.
 * Contrary to `Member`, it doesn't have any `added_at` field
 * since this field cannot be set as part of requests.
 *
 * @generated from message cosmos.group.v1.MemberRequest
 */
export type MemberRequest = Message<"cosmos.group.v1.MemberRequest"> & {
  /**
   * address is the member's account address.
   *
   * @generated from field: string address = 1;
   */
  address: string;

  /**
   * weight is the member's voting weight that should be greater than 0.
   *
   * @generated from field: string weight = 2;
   */
  weight: string;

  /**
   * metadata is any arbitrary metadata attached to the member.
   *
   * @generated from field: string metadata = 3;
   */
  metadata: string;
};

/**
 * MemberRequest represents a group member to be used in Msg server requests.
 * Contrary to `Member`, it doesn't have any `added_at` field
 * since this field cannot be set as part of requests.
 *
 * @generated from message cosmos.group.v1.MemberRequest
 */
export type MemberRequestJson = {
  /**
   * address is the member's account address.
   *
   * @generated from field: string address = 1;
   */
  address?: string;

  /**
   * weight is the member's voting weight that should be greater than 0.
   *
   * @generated from field: string weight = 2;
   */
  weight?: string;

  /**
   * metadata is any arbitrary metadata attached to the member.
   *
   * @generated from field: string metadata = 3;
   */
  metadata?: string;
};

/**
 * Describes the message cosmos.group.v1.MemberRequest.
 * Use `create(MemberRequestSchema)` to create a new message.
 */
export const MemberRequestSchema: GenMessage<MemberRequest, MemberRequestJson> = /*@__PURE__*/
  messageDesc(file_cosmos_group_v1_types, 1);

/**
 * ThresholdDecisionPolicy is a decision policy where a proposal passes when it
 * satisfies the two following conditions:
 * 1. The sum of all `YES` voter's weights is greater or equal than the defined
 *    `threshold`.
 * 2. The voting and execution periods of the proposal respect the parameters
 *    given by `windows`.
 *
 * @generated from message cosmos.group.v1.ThresholdDecisionPolicy
 */
export type ThresholdDecisionPolicy = Message<"cosmos.group.v1.ThresholdDecisionPolicy"> & {
  /**
   * threshold is the minimum weighted sum of `YES` votes that must be met or
   * exceeded for a proposal to succeed.
   *
   * @generated from field: string threshold = 1;
   */
  threshold: string;

  /**
   * windows defines the different windows for voting and execution.
   *
   * @generated from field: cosmos.group.v1.DecisionPolicyWindows windows = 2;
   */
  windows?: DecisionPolicyWindows;
};

/**
 * ThresholdDecisionPolicy is a decision policy where a proposal passes when it
 * satisfies the two following conditions:
 * 1. The sum of all `YES` voter's weights is greater or equal than the defined
 *    `threshold`.
 * 2. The voting and execution periods of the proposal respect the parameters
 *    given by `windows`.
 *
 * @generated from message cosmos.group.v1.ThresholdDecisionPolicy
 */
export type ThresholdDecisionPolicyJson = {
  /**
   * threshold is the minimum weighted sum of `YES` votes that must be met or
   * exceeded for a proposal to succeed.
   *
   * @generated from field: string threshold = 1;
   */
  threshold?: string;

  /**
   * windows defines the different windows for voting and execution.
   *
   * @generated from field: cosmos.group.v1.DecisionPolicyWindows windows = 2;
   */
  windows?: DecisionPolicyWindowsJson;
};

/**
 * Describes the message cosmos.group.v1.ThresholdDecisionPolicy.
 * Use `create(ThresholdDecisionPolicySchema)` to create a new message.
 */
export const ThresholdDecisionPolicySchema: GenMessage<ThresholdDecisionPolicy, ThresholdDecisionPolicyJson> = /*@__PURE__*/
  messageDesc(file_cosmos_group_v1_types, 2);

/**
 * PercentageDecisionPolicy is a decision policy where a proposal passes when
 * it satisfies the two following conditions:
 * 1. The percentage of all `YES` voters' weights out of the total group weight
 *    is greater or equal than the given `percentage`.
 * 2. The voting and execution periods of the proposal respect the parameters
 *    given by `windows`.
 *
 * @generated from message cosmos.group.v1.PercentageDecisionPolicy
 */
export type PercentageDecisionPolicy = Message<"cosmos.group.v1.PercentageDecisionPolicy"> & {
  /**
   * percentage is the minimum percentage of the weighted sum of `YES` votes must
   * meet for a proposal to succeed.
   *
   * @generated from field: string percentage = 1;
   */
  percentage: string;

  /**
   * windows defines the different windows for voting and execution.
   *
   * @generated from field: cosmos.group.v1.DecisionPolicyWindows windows = 2;
   */
  windows?: DecisionPolicyWindows;
};

/**
 * PercentageDecisionPolicy is a decision policy where a proposal passes when
 * it satisfies the two following conditions:
 * 1. The percentage of all `YES` voters' weights out of the total group weight
 *    is greater or equal than the given `percentage`.
 * 2. The voting and execution periods of the proposal respect the parameters
 *    given by `windows`.
 *
 * @generated from message cosmos.group.v1.PercentageDecisionPolicy
 */
export type PercentageDecisionPolicyJson = {
  /**
   * percentage is the minimum percentage of the weighted sum of `YES` votes must
   * meet for a proposal to succeed.
   *
   * @generated from field: string percentage = 1;
   */
  percentage?: string;

  /**
   * windows defines the different windows for voting and execution.
   *
   * @generated from field: cosmos.group.v1.DecisionPolicyWindows windows = 2;
   */
  windows?: DecisionPolicyWindowsJson;
};

/**
 * Describes the message cosmos.group.v1.PercentageDecisionPolicy.
 * Use `create(PercentageDecisionPolicySchema)` to create a new message.
 */
export const PercentageDecisionPolicySchema: GenMessage<PercentageDecisionPolicy, PercentageDecisionPolicyJson> = /*@__PURE__*/
  messageDesc(file_cosmos_group_v1_types, 3);

/**
 * DecisionPolicyWindows defines the different windows for voting and execution.
 *
 * @generated from message cosmos.group.v1.DecisionPolicyWindows
 */
export type DecisionPolicyWindows = Message<"cosmos.group.v1.DecisionPolicyWindows"> & {
  /**
   * voting_period is the duration from submission of a proposal to the end of voting period
   * Within this times votes can be submitted with MsgVote.
   *
   * @generated from field: google.protobuf.Duration voting_period = 1;
   */
  votingPeriod?: Duration;

  /**
   * min_execution_period is the minimum duration after the proposal submission
   * where members can start sending MsgExec. This means that the window for
   * sending a MsgExec transaction is:
   * `[ submission + min_execution_period ; submission + voting_period + max_execution_period]`
   * where max_execution_period is a app-specific config, defined in the keeper.
   * If not set, min_execution_period will default to 0.
   *
   * Please make sure to set a `min_execution_period` that is smaller than
   * `voting_period + max_execution_period`, or else the above execution window
   * is empty, meaning that all proposals created with this decision policy
   * won't be able to be executed.
   *
   * @generated from field: google.protobuf.Duration min_execution_period = 2;
   */
  minExecutionPeriod?: Duration;
};

/**
 * DecisionPolicyWindows defines the different windows for voting and execution.
 *
 * @generated from message cosmos.group.v1.DecisionPolicyWindows
 */
export type DecisionPolicyWindowsJson = {
  /**
   * voting_period is the duration from submission of a proposal to the end of voting period
   * Within this times votes can be submitted with MsgVote.
   *
   * @generated from field: google.protobuf.Duration voting_period = 1;
   */
  votingPeriod?: DurationJson;

  /**
   * min_execution_period is the minimum duration after the proposal submission
   * where members can start sending MsgExec. This means that the window for
   * sending a MsgExec transaction is:
   * `[ submission + min_execution_period ; submission + voting_period + max_execution_period]`
   * where max_execution_period is a app-specific config, defined in the keeper.
   * If not set, min_execution_period will default to 0.
   *
   * Please make sure to set a `min_execution_period` that is smaller than
   * `voting_period + max_execution_period`, or else the above execution window
   * is empty, meaning that all proposals created with this decision policy
   * won't be able to be executed.
   *
   * @generated from field: google.protobuf.Duration min_execution_period = 2;
   */
  minExecutionPeriod?: DurationJson;
};

/**
 * Describes the message cosmos.group.v1.DecisionPolicyWindows.
 * Use `create(DecisionPolicyWindowsSchema)` to create a new message.
 */
export const DecisionPolicyWindowsSchema: GenMessage<DecisionPolicyWindows, DecisionPolicyWindowsJson> = /*@__PURE__*/
  messageDesc(file_cosmos_group_v1_types, 4);

/**
 * GroupInfo represents the high-level on-chain information for a group.
 *
 * @generated from message cosmos.group.v1.GroupInfo
 */
export type GroupInfo = Message<"cosmos.group.v1.GroupInfo"> & {
  /**
   * id is the unique ID of the group.
   *
   * @generated from field: uint64 id = 1;
   */
  id: bigint;

  /**
   * admin is the account address of the group's admin.
   *
   * @generated from field: string admin = 2;
   */
  admin: string;

  /**
   * metadata is any arbitrary metadata to attached to the group.
   *
   * @generated from field: string metadata = 3;
   */
  metadata: string;

  /**
   * version is used to track changes to a group's membership structure that
   * would break existing proposals. Whenever any members weight is changed,
   * or any member is added or removed this version is incremented and will
   * cause proposals based on older versions of this group to fail
   *
   * @generated from field: uint64 version = 4;
   */
  version: bigint;

  /**
   * total_weight is the sum of the group members' weights.
   *
   * @generated from field: string total_weight = 5;
   */
  totalWeight: string;

  /**
   * created_at is a timestamp specifying when a group was created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 6;
   */
  createdAt?: Timestamp;
};

/**
 * GroupInfo represents the high-level on-chain information for a group.
 *
 * @generated from message cosmos.group.v1.GroupInfo
 */
export type GroupInfoJson = {
  /**
   * id is the unique ID of the group.
   *
   * @generated from field: uint64 id = 1;
   */
  id?: string;

  /**
   * admin is the account address of the group's admin.
   *
   * @generated from field: string admin = 2;
   */
  admin?: string;

  /**
   * metadata is any arbitrary metadata to attached to the group.
   *
   * @generated from field: string metadata = 3;
   */
  metadata?: string;

  /**
   * version is used to track changes to a group's membership structure that
   * would break existing proposals. Whenever any members weight is changed,
   * or any member is added or removed this version is incremented and will
   * cause proposals based on older versions of this group to fail
   *
   * @generated from field: uint64 version = 4;
   */
  version?: string;

  /**
   * total_weight is the sum of the group members' weights.
   *
   * @generated from field: string total_weight = 5;
   */
  totalWeight?: string;

  /**
   * created_at is a timestamp specifying when a group was created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 6;
   */
  createdAt?: TimestampJson;
};

/**
 * Describes the message cosmos.group.v1.GroupInfo.
 * Use `create(GroupInfoSchema)` to create a new message.
 */
export const GroupInfoSchema: GenMessage<GroupInfo, GroupInfoJson> = /*@__PURE__*/
  messageDesc(file_cosmos_group_v1_types, 5);

/**
 * GroupMember represents the relationship between a group and a member.
 *
 * @generated from message cosmos.group.v1.GroupMember
 */
export type GroupMember = Message<"cosmos.group.v1.GroupMember"> & {
  /**
   * group_id is the unique ID of the group.
   *
   * @generated from field: uint64 group_id = 1;
   */
  groupId: bigint;

  /**
   * member is the member data.
   *
   * @generated from field: cosmos.group.v1.Member member = 2;
   */
  member?: Member;
};

/**
 * GroupMember represents the relationship between a group and a member.
 *
 * @generated from message cosmos.group.v1.GroupMember
 */
export type GroupMemberJson = {
  /**
   * group_id is the unique ID of the group.
   *
   * @generated from field: uint64 group_id = 1;
   */
  groupId?: string;

  /**
   * member is the member data.
   *
   * @generated from field: cosmos.group.v1.Member member = 2;
   */
  member?: MemberJson;
};

/**
 * Describes the message cosmos.group.v1.GroupMember.
 * Use `create(GroupMemberSchema)` to create a new message.
 */
export const GroupMemberSchema: GenMessage<GroupMember, GroupMemberJson> = /*@__PURE__*/
  messageDesc(file_cosmos_group_v1_types, 6);

/**
 * GroupPolicyInfo represents the high-level on-chain information for a group policy.
 *
 * @generated from message cosmos.group.v1.GroupPolicyInfo
 */
export type GroupPolicyInfo = Message<"cosmos.group.v1.GroupPolicyInfo"> & {
  /**
   * address is the account address of group policy.
   *
   * @generated from field: string address = 1;
   */
  address: string;

  /**
   * group_id is the unique ID of the group.
   *
   * @generated from field: uint64 group_id = 2;
   */
  groupId: bigint;

  /**
   * admin is the account address of the group admin.
   *
   * @generated from field: string admin = 3;
   */
  admin: string;

  /**
   * metadata is any arbitrary metadata attached to the group policy.
   * the recommended format of the metadata is to be found here:
   * https://docs.cosmos.network/v0.47/modules/group#decision-policy-1
   *
   * @generated from field: string metadata = 4;
   */
  metadata: string;

  /**
   * version is used to track changes to a group's GroupPolicyInfo structure that
   * would create a different result on a running proposal.
   *
   * @generated from field: uint64 version = 5;
   */
  version: bigint;

  /**
   * decision_policy specifies the group policy's decision policy.
   *
   * @generated from field: google.protobuf.Any decision_policy = 6;
   */
  decisionPolicy?: Any;

  /**
   * created_at is a timestamp specifying when a group policy was created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 7;
   */
  createdAt?: Timestamp;
};

/**
 * GroupPolicyInfo represents the high-level on-chain information for a group policy.
 *
 * @generated from message cosmos.group.v1.GroupPolicyInfo
 */
export type GroupPolicyInfoJson = {
  /**
   * address is the account address of group policy.
   *
   * @generated from field: string address = 1;
   */
  address?: string;

  /**
   * group_id is the unique ID of the group.
   *
   * @generated from field: uint64 group_id = 2;
   */
  groupId?: string;

  /**
   * admin is the account address of the group admin.
   *
   * @generated from field: string admin = 3;
   */
  admin?: string;

  /**
   * metadata is any arbitrary metadata attached to the group policy.
   * the recommended format of the metadata is to be found here:
   * https://docs.cosmos.network/v0.47/modules/group#decision-policy-1
   *
   * @generated from field: string metadata = 4;
   */
  metadata?: string;

  /**
   * version is used to track changes to a group's GroupPolicyInfo structure that
   * would create a different result on a running proposal.
   *
   * @generated from field: uint64 version = 5;
   */
  version?: string;

  /**
   * decision_policy specifies the group policy's decision policy.
   *
   * @generated from field: google.protobuf.Any decision_policy = 6;
   */
  decisionPolicy?: AnyJson;

  /**
   * created_at is a timestamp specifying when a group policy was created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 7;
   */
  createdAt?: TimestampJson;
};

/**
 * Describes the message cosmos.group.v1.GroupPolicyInfo.
 * Use `create(GroupPolicyInfoSchema)` to create a new message.
 */
export const GroupPolicyInfoSchema: GenMessage<GroupPolicyInfo, GroupPolicyInfoJson> = /*@__PURE__*/
  messageDesc(file_cosmos_group_v1_types, 7);

/**
 * Proposal defines a group proposal. Any member of a group can submit a proposal
 * for a group policy to decide upon.
 * A proposal consists of a set of `sdk.Msg`s that will be executed if the proposal
 * passes as well as some optional metadata associated with the proposal.
 *
 * @generated from message cosmos.group.v1.Proposal
 */
export type Proposal = Message<"cosmos.group.v1.Proposal"> & {
  /**
   * id is the unique id of the proposal.
   *
   * @generated from field: uint64 id = 1;
   */
  id: bigint;

  /**
   * group_policy_address is the account address of group policy.
   *
   * @generated from field: string group_policy_address = 2;
   */
  groupPolicyAddress: string;

  /**
   * metadata is any arbitrary metadata attached to the proposal.
   * the recommended format of the metadata is to be found here:
   * https://docs.cosmos.network/v0.47/modules/group#proposal-4
   *
   * @generated from field: string metadata = 3;
   */
  metadata: string;

  /**
   * proposers are the account addresses of the proposers.
   *
   * @generated from field: repeated string proposers = 4;
   */
  proposers: string[];

  /**
   * submit_time is a timestamp specifying when a proposal was submitted.
   *
   * @generated from field: google.protobuf.Timestamp submit_time = 5;
   */
  submitTime?: Timestamp;

  /**
   * group_version tracks the version of the group at proposal submission.
   * This field is here for informational purposes only.
   *
   * @generated from field: uint64 group_version = 6;
   */
  groupVersion: bigint;

  /**
   * group_policy_version tracks the version of the group policy at proposal submission.
   * When a decision policy is changed, existing proposals from previous policy
   * versions will become invalid with the `ABORTED` status.
   * This field is here for informational purposes only.
   *
   * @generated from field: uint64 group_policy_version = 7;
   */
  groupPolicyVersion: bigint;

  /**
   * status represents the high level position in the life cycle of the proposal. Initial value is Submitted.
   *
   * @generated from field: cosmos.group.v1.ProposalStatus status = 8;
   */
  status: ProposalStatus;

  /**
   * final_tally_result contains the sums of all weighted votes for this
   * proposal for each vote option. It is empty at submission, and only
   * populated after tallying, at voting period end or at proposal execution,
   * whichever happens first.
   *
   * @generated from field: cosmos.group.v1.TallyResult final_tally_result = 9;
   */
  finalTallyResult?: TallyResult;

  /**
   * voting_period_end is the timestamp before which voting must be done.
   * Unless a successful MsgExec is called before (to execute a proposal whose
   * tally is successful before the voting period ends), tallying will be done
   * at this point, and the `final_tally_result`and `status` fields will be
   * accordingly updated.
   *
   * @generated from field: google.protobuf.Timestamp voting_period_end = 10;
   */
  votingPeriodEnd?: Timestamp;

  /**
   * executor_result is the final result of the proposal execution. Initial value is NotRun.
   *
   * @generated from field: cosmos.group.v1.ProposalExecutorResult executor_result = 11;
   */
  executorResult: ProposalExecutorResult;

  /**
   * messages is a list of `sdk.Msg`s that will be executed if the proposal passes.
   *
   * @generated from field: repeated google.protobuf.Any messages = 12;
   */
  messages: Any[];

  /**
   * title is the title of the proposal
   *
   * Since: cosmos-sdk 0.47
   *
   * @generated from field: string title = 13;
   */
  title: string;

  /**
   * summary is a short summary of the proposal
   *
   * Since: cosmos-sdk 0.47
   *
   * @generated from field: string summary = 14;
   */
  summary: string;
};

/**
 * Proposal defines a group proposal. Any member of a group can submit a proposal
 * for a group policy to decide upon.
 * A proposal consists of a set of `sdk.Msg`s that will be executed if the proposal
 * passes as well as some optional metadata associated with the proposal.
 *
 * @generated from message cosmos.group.v1.Proposal
 */
export type ProposalJson = {
  /**
   * id is the unique id of the proposal.
   *
   * @generated from field: uint64 id = 1;
   */
  id?: string;

  /**
   * group_policy_address is the account address of group policy.
   *
   * @generated from field: string group_policy_address = 2;
   */
  groupPolicyAddress?: string;

  /**
   * metadata is any arbitrary metadata attached to the proposal.
   * the recommended format of the metadata is to be found here:
   * https://docs.cosmos.network/v0.47/modules/group#proposal-4
   *
   * @generated from field: string metadata = 3;
   */
  metadata?: string;

  /**
   * proposers are the account addresses of the proposers.
   *
   * @generated from field: repeated string proposers = 4;
   */
  proposers?: string[];

  /**
   * submit_time is a timestamp specifying when a proposal was submitted.
   *
   * @generated from field: google.protobuf.Timestamp submit_time = 5;
   */
  submitTime?: TimestampJson;

  /**
   * group_version tracks the version of the group at proposal submission.
   * This field is here for informational purposes only.
   *
   * @generated from field: uint64 group_version = 6;
   */
  groupVersion?: string;

  /**
   * group_policy_version tracks the version of the group policy at proposal submission.
   * When a decision policy is changed, existing proposals from previous policy
   * versions will become invalid with the `ABORTED` status.
   * This field is here for informational purposes only.
   *
   * @generated from field: uint64 group_policy_version = 7;
   */
  groupPolicyVersion?: string;

  /**
   * status represents the high level position in the life cycle of the proposal. Initial value is Submitted.
   *
   * @generated from field: cosmos.group.v1.ProposalStatus status = 8;
   */
  status?: ProposalStatusJson;

  /**
   * final_tally_result contains the sums of all weighted votes for this
   * proposal for each vote option. It is empty at submission, and only
   * populated after tallying, at voting period end or at proposal execution,
   * whichever happens first.
   *
   * @generated from field: cosmos.group.v1.TallyResult final_tally_result = 9;
   */
  finalTallyResult?: TallyResultJson;

  /**
   * voting_period_end is the timestamp before which voting must be done.
   * Unless a successful MsgExec is called before (to execute a proposal whose
   * tally is successful before the voting period ends), tallying will be done
   * at this point, and the `final_tally_result`and `status` fields will be
   * accordingly updated.
   *
   * @generated from field: google.protobuf.Timestamp voting_period_end = 10;
   */
  votingPeriodEnd?: TimestampJson;

  /**
   * executor_result is the final result of the proposal execution. Initial value is NotRun.
   *
   * @generated from field: cosmos.group.v1.ProposalExecutorResult executor_result = 11;
   */
  executorResult?: ProposalExecutorResultJson;

  /**
   * messages is a list of `sdk.Msg`s that will be executed if the proposal passes.
   *
   * @generated from field: repeated google.protobuf.Any messages = 12;
   */
  messages?: AnyJson[];

  /**
   * title is the title of the proposal
   *
   * Since: cosmos-sdk 0.47
   *
   * @generated from field: string title = 13;
   */
  title?: string;

  /**
   * summary is a short summary of the proposal
   *
   * Since: cosmos-sdk 0.47
   *
   * @generated from field: string summary = 14;
   */
  summary?: string;
};

/**
 * Describes the message cosmos.group.v1.Proposal.
 * Use `create(ProposalSchema)` to create a new message.
 */
export const ProposalSchema: GenMessage<Proposal, ProposalJson> = /*@__PURE__*/
  messageDesc(file_cosmos_group_v1_types, 8);

/**
 * TallyResult represents the sum of weighted votes for each vote option.
 *
 * @generated from message cosmos.group.v1.TallyResult
 */
export type TallyResult = Message<"cosmos.group.v1.TallyResult"> & {
  /**
   * yes_count is the weighted sum of yes votes.
   *
   * @generated from field: string yes_count = 1;
   */
  yesCount: string;

  /**
   * abstain_count is the weighted sum of abstainers.
   *
   * @generated from field: string abstain_count = 2;
   */
  abstainCount: string;

  /**
   * no_count is the weighted sum of no votes.
   *
   * @generated from field: string no_count = 3;
   */
  noCount: string;

  /**
   * no_with_veto_count is the weighted sum of veto.
   *
   * @generated from field: string no_with_veto_count = 4;
   */
  noWithVetoCount: string;
};

/**
 * TallyResult represents the sum of weighted votes for each vote option.
 *
 * @generated from message cosmos.group.v1.TallyResult
 */
export type TallyResultJson = {
  /**
   * yes_count is the weighted sum of yes votes.
   *
   * @generated from field: string yes_count = 1;
   */
  yesCount?: string;

  /**
   * abstain_count is the weighted sum of abstainers.
   *
   * @generated from field: string abstain_count = 2;
   */
  abstainCount?: string;

  /**
   * no_count is the weighted sum of no votes.
   *
   * @generated from field: string no_count = 3;
   */
  noCount?: string;

  /**
   * no_with_veto_count is the weighted sum of veto.
   *
   * @generated from field: string no_with_veto_count = 4;
   */
  noWithVetoCount?: string;
};

/**
 * Describes the message cosmos.group.v1.TallyResult.
 * Use `create(TallyResultSchema)` to create a new message.
 */
export const TallyResultSchema: GenMessage<TallyResult, TallyResultJson> = /*@__PURE__*/
  messageDesc(file_cosmos_group_v1_types, 9);

/**
 * Vote represents a vote for a proposal.
 *
 * @generated from message cosmos.group.v1.Vote
 */
export type Vote = Message<"cosmos.group.v1.Vote"> & {
  /**
   * proposal is the unique ID of the proposal.
   *
   * @generated from field: uint64 proposal_id = 1;
   */
  proposalId: bigint;

  /**
   * voter is the account address of the voter.
   *
   * @generated from field: string voter = 2;
   */
  voter: string;

  /**
   * option is the voter's choice on the proposal.
   *
   * @generated from field: cosmos.group.v1.VoteOption option = 3;
   */
  option: VoteOption;

  /**
   * metadata is any arbitrary metadata attached to the vote.
   *
   * @generated from field: string metadata = 4;
   */
  metadata: string;

  /**
   * submit_time is the timestamp when the vote was submitted.
   *
   * @generated from field: google.protobuf.Timestamp submit_time = 5;
   */
  submitTime?: Timestamp;
};

/**
 * Vote represents a vote for a proposal.
 *
 * @generated from message cosmos.group.v1.Vote
 */
export type VoteJson = {
  /**
   * proposal is the unique ID of the proposal.
   *
   * @generated from field: uint64 proposal_id = 1;
   */
  proposalId?: string;

  /**
   * voter is the account address of the voter.
   *
   * @generated from field: string voter = 2;
   */
  voter?: string;

  /**
   * option is the voter's choice on the proposal.
   *
   * @generated from field: cosmos.group.v1.VoteOption option = 3;
   */
  option?: VoteOptionJson;

  /**
   * metadata is any arbitrary metadata attached to the vote.
   *
   * @generated from field: string metadata = 4;
   */
  metadata?: string;

  /**
   * submit_time is the timestamp when the vote was submitted.
   *
   * @generated from field: google.protobuf.Timestamp submit_time = 5;
   */
  submitTime?: TimestampJson;
};

/**
 * Describes the message cosmos.group.v1.Vote.
 * Use `create(VoteSchema)` to create a new message.
 */
export const VoteSchema: GenMessage<Vote, VoteJson> = /*@__PURE__*/
  messageDesc(file_cosmos_group_v1_types, 10);

/**
 * VoteOption enumerates the valid vote options for a given proposal.
 *
 * @generated from enum cosmos.group.v1.VoteOption
 */
export enum VoteOption {
  /**
   * VOTE_OPTION_UNSPECIFIED defines an unspecified vote option which will
   * return an error.
   *
   * @generated from enum value: VOTE_OPTION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * VOTE_OPTION_YES defines a yes vote option.
   *
   * @generated from enum value: VOTE_OPTION_YES = 1;
   */
  YES = 1,

  /**
   * VOTE_OPTION_ABSTAIN defines an abstain vote option.
   *
   * @generated from enum value: VOTE_OPTION_ABSTAIN = 2;
   */
  ABSTAIN = 2,

  /**
   * VOTE_OPTION_NO defines a no vote option.
   *
   * @generated from enum value: VOTE_OPTION_NO = 3;
   */
  NO = 3,

  /**
   * VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.
   *
   * @generated from enum value: VOTE_OPTION_NO_WITH_VETO = 4;
   */
  NO_WITH_VETO = 4,
}

/**
 * VoteOption enumerates the valid vote options for a given proposal.
 *
 * @generated from enum cosmos.group.v1.VoteOption
 */
export type VoteOptionJson = "VOTE_OPTION_UNSPECIFIED" | "VOTE_OPTION_YES" | "VOTE_OPTION_ABSTAIN" | "VOTE_OPTION_NO" | "VOTE_OPTION_NO_WITH_VETO";

/**
 * Describes the enum cosmos.group.v1.VoteOption.
 */
export const VoteOptionSchema: GenEnum<VoteOption, VoteOptionJson> = /*@__PURE__*/
  enumDesc(file_cosmos_group_v1_types, 0);

/**
 * ProposalStatus defines proposal statuses.
 *
 * @generated from enum cosmos.group.v1.ProposalStatus
 */
export enum ProposalStatus {
  /**
   * An empty value is invalid and not allowed.
   *
   * @generated from enum value: PROPOSAL_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Initial status of a proposal when submitted.
   *
   * @generated from enum value: PROPOSAL_STATUS_SUBMITTED = 1;
   */
  SUBMITTED = 1,

  /**
   * Final status of a proposal when the final tally is done and the outcome
   * passes the group policy's decision policy.
   *
   * @generated from enum value: PROPOSAL_STATUS_ACCEPTED = 2;
   */
  ACCEPTED = 2,

  /**
   * Final status of a proposal when the final tally is done and the outcome
   * is rejected by the group policy's decision policy.
   *
   * @generated from enum value: PROPOSAL_STATUS_REJECTED = 3;
   */
  REJECTED = 3,

  /**
   * Final status of a proposal when the group policy is modified before the
   * final tally.
   *
   * @generated from enum value: PROPOSAL_STATUS_ABORTED = 4;
   */
  ABORTED = 4,

  /**
   * A proposal can be withdrawn before the voting start time by the owner.
   * When this happens the final status is Withdrawn.
   *
   * @generated from enum value: PROPOSAL_STATUS_WITHDRAWN = 5;
   */
  WITHDRAWN = 5,
}

/**
 * ProposalStatus defines proposal statuses.
 *
 * @generated from enum cosmos.group.v1.ProposalStatus
 */
export type ProposalStatusJson = "PROPOSAL_STATUS_UNSPECIFIED" | "PROPOSAL_STATUS_SUBMITTED" | "PROPOSAL_STATUS_ACCEPTED" | "PROPOSAL_STATUS_REJECTED" | "PROPOSAL_STATUS_ABORTED" | "PROPOSAL_STATUS_WITHDRAWN";

/**
 * Describes the enum cosmos.group.v1.ProposalStatus.
 */
export const ProposalStatusSchema: GenEnum<ProposalStatus, ProposalStatusJson> = /*@__PURE__*/
  enumDesc(file_cosmos_group_v1_types, 1);

/**
 * ProposalExecutorResult defines types of proposal executor results.
 *
 * @generated from enum cosmos.group.v1.ProposalExecutorResult
 */
export enum ProposalExecutorResult {
  /**
   * An empty value is not allowed.
   *
   * @generated from enum value: PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * We have not yet run the executor.
   *
   * @generated from enum value: PROPOSAL_EXECUTOR_RESULT_NOT_RUN = 1;
   */
  NOT_RUN = 1,

  /**
   * The executor was successful and proposed action updated state.
   *
   * @generated from enum value: PROPOSAL_EXECUTOR_RESULT_SUCCESS = 2;
   */
  SUCCESS = 2,

  /**
   * The executor returned an error and proposed action didn't update state.
   *
   * @generated from enum value: PROPOSAL_EXECUTOR_RESULT_FAILURE = 3;
   */
  FAILURE = 3,
}

/**
 * ProposalExecutorResult defines types of proposal executor results.
 *
 * @generated from enum cosmos.group.v1.ProposalExecutorResult
 */
export type ProposalExecutorResultJson = "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED" | "PROPOSAL_EXECUTOR_RESULT_NOT_RUN" | "PROPOSAL_EXECUTOR_RESULT_SUCCESS" | "PROPOSAL_EXECUTOR_RESULT_FAILURE";

/**
 * Describes the enum cosmos.group.v1.ProposalExecutorResult.
 */
export const ProposalExecutorResultSchema: GenEnum<ProposalExecutorResult, ProposalExecutorResultJson> = /*@__PURE__*/
  enumDesc(file_cosmos_group_v1_types, 2);

