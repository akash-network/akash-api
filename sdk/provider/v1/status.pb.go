// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: akash/provider/v1/status.proto

package v1

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	v1 "go.akashd.io/sdk/inventory/v1"
	io "io"
	resource "k8s.io/apimachinery/pkg/api/resource"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ResourceMetrics
type ResourcesMetric struct {
	CPU              *resource.Quantity `protobuf:"bytes,1,opt,name=cpu,proto3" json:"cpu" yaml:"cpu"`
	Memory           *resource.Quantity `protobuf:"bytes,2,opt,name=memory,proto3" json:"memory" yaml:"memory"`
	GPU              *resource.Quantity `protobuf:"bytes,3,opt,name=gpu,proto3,castrepeated=GPUs" json:"gpu" yaml:"gpu"`
	EphemeralStorage *resource.Quantity `protobuf:"bytes,4,opt,name=ephemeral_storage,json=ephemeralStorage,proto3" json:"ephemeral_storage" yaml:"ephemeral_storage"`
	Storage          Storage            `protobuf:"bytes,5,rep,name=storage,proto3,casttype=Storage" json:"storage" yaml:"storage" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ResourcesMetric) Reset()         { *m = ResourcesMetric{} }
func (m *ResourcesMetric) String() string { return proto.CompactTextString(m) }
func (*ResourcesMetric) ProtoMessage()    {}
func (*ResourcesMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ba712d181b7fc9b, []int{0}
}
func (m *ResourcesMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourcesMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourcesMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourcesMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourcesMetric.Merge(m, src)
}
func (m *ResourcesMetric) XXX_Size() int {
	return m.Size()
}
func (m *ResourcesMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourcesMetric.DiscardUnknown(m)
}

var xxx_messageInfo_ResourcesMetric proto.InternalMessageInfo

func (m *ResourcesMetric) GetCPU() *resource.Quantity {
	if m != nil {
		return m.CPU
	}
	return nil
}

func (m *ResourcesMetric) GetMemory() *resource.Quantity {
	if m != nil {
		return m.Memory
	}
	return nil
}

func (m *ResourcesMetric) GetGPU() *resource.Quantity {
	if m != nil {
		return m.GPU
	}
	return nil
}

func (m *ResourcesMetric) GetEphemeralStorage() *resource.Quantity {
	if m != nil {
		return m.EphemeralStorage
	}
	return nil
}

func (m *ResourcesMetric) GetStorage() Storage {
	if m != nil {
		return m.Storage
	}
	return nil
}

// Leases
type Leases struct {
	Active uint32 `protobuf:"varint,1,opt,name=active,proto3" json:"active" yaml:"active"`
}

func (m *Leases) Reset()         { *m = Leases{} }
func (m *Leases) String() string { return proto.CompactTextString(m) }
func (*Leases) ProtoMessage()    {}
func (*Leases) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ba712d181b7fc9b, []int{1}
}
func (m *Leases) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Leases) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Leases.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Leases) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Leases.Merge(m, src)
}
func (m *Leases) XXX_Size() int {
	return m.Size()
}
func (m *Leases) XXX_DiscardUnknown() {
	xxx_messageInfo_Leases.DiscardUnknown(m)
}

var xxx_messageInfo_Leases proto.InternalMessageInfo

func (m *Leases) GetActive() uint32 {
	if m != nil {
		return m.Active
	}
	return 0
}

// ReservationsMetric
type ReservationsMetric struct {
	Count     uint32          `protobuf:"varint,1,opt,name=count,proto3" json:"count" yaml:"count"`
	Resources ResourcesMetric `protobuf:"bytes,2,opt,name=resources,proto3" json:"resources" yaml:"resources"`
}

func (m *ReservationsMetric) Reset()         { *m = ReservationsMetric{} }
func (m *ReservationsMetric) String() string { return proto.CompactTextString(m) }
func (*ReservationsMetric) ProtoMessage()    {}
func (*ReservationsMetric) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ba712d181b7fc9b, []int{2}
}
func (m *ReservationsMetric) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReservationsMetric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReservationsMetric.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReservationsMetric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReservationsMetric.Merge(m, src)
}
func (m *ReservationsMetric) XXX_Size() int {
	return m.Size()
}
func (m *ReservationsMetric) XXX_DiscardUnknown() {
	xxx_messageInfo_ReservationsMetric.DiscardUnknown(m)
}

var xxx_messageInfo_ReservationsMetric proto.InternalMessageInfo

func (m *ReservationsMetric) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *ReservationsMetric) GetResources() ResourcesMetric {
	if m != nil {
		return m.Resources
	}
	return ResourcesMetric{}
}

// Reservations
type Reservations struct {
	Pending ReservationsMetric `protobuf:"bytes,1,opt,name=pending,proto3" json:"pending" yaml:"pending"`
	Active  ReservationsMetric `protobuf:"bytes,2,opt,name=active,proto3" json:"active" yaml:"active"`
}

func (m *Reservations) Reset()         { *m = Reservations{} }
func (m *Reservations) String() string { return proto.CompactTextString(m) }
func (*Reservations) ProtoMessage()    {}
func (*Reservations) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ba712d181b7fc9b, []int{3}
}
func (m *Reservations) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Reservations) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Reservations.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Reservations) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Reservations.Merge(m, src)
}
func (m *Reservations) XXX_Size() int {
	return m.Size()
}
func (m *Reservations) XXX_DiscardUnknown() {
	xxx_messageInfo_Reservations.DiscardUnknown(m)
}

var xxx_messageInfo_Reservations proto.InternalMessageInfo

func (m *Reservations) GetPending() ReservationsMetric {
	if m != nil {
		return m.Pending
	}
	return ReservationsMetric{}
}

func (m *Reservations) GetActive() ReservationsMetric {
	if m != nil {
		return m.Active
	}
	return ReservationsMetric{}
}

// Inventory
type Inventory struct {
	Cluster      v1.Cluster   `protobuf:"bytes,1,opt,name=cluster,proto3" json:"cluster" yaml:"cluster"`
	Reservations Reservations `protobuf:"bytes,2,opt,name=reservations,proto3" json:"reservations" yaml:"reservations"`
}

func (m *Inventory) Reset()         { *m = Inventory{} }
func (m *Inventory) String() string { return proto.CompactTextString(m) }
func (*Inventory) ProtoMessage()    {}
func (*Inventory) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ba712d181b7fc9b, []int{4}
}
func (m *Inventory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Inventory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Inventory.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Inventory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Inventory.Merge(m, src)
}
func (m *Inventory) XXX_Size() int {
	return m.Size()
}
func (m *Inventory) XXX_DiscardUnknown() {
	xxx_messageInfo_Inventory.DiscardUnknown(m)
}

var xxx_messageInfo_Inventory proto.InternalMessageInfo

func (m *Inventory) GetCluster() v1.Cluster {
	if m != nil {
		return m.Cluster
	}
	return v1.Cluster{}
}

func (m *Inventory) GetReservations() Reservations {
	if m != nil {
		return m.Reservations
	}
	return Reservations{}
}

// ClusterStatus
type ClusterStatus struct {
	Leases    Leases    `protobuf:"bytes,1,opt,name=leases,proto3" json:"leases" yaml:"leases"`
	Inventory Inventory `protobuf:"bytes,2,opt,name=inventory,proto3" json:"inventory" yaml:"inventory"`
}

func (m *ClusterStatus) Reset()         { *m = ClusterStatus{} }
func (m *ClusterStatus) String() string { return proto.CompactTextString(m) }
func (*ClusterStatus) ProtoMessage()    {}
func (*ClusterStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ba712d181b7fc9b, []int{5}
}
func (m *ClusterStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterStatus.Merge(m, src)
}
func (m *ClusterStatus) XXX_Size() int {
	return m.Size()
}
func (m *ClusterStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterStatus proto.InternalMessageInfo

func (m *ClusterStatus) GetLeases() Leases {
	if m != nil {
		return m.Leases
	}
	return Leases{}
}

func (m *ClusterStatus) GetInventory() Inventory {
	if m != nil {
		return m.Inventory
	}
	return Inventory{}
}

// BidEngineStatus
type BidEngineStatus struct {
	Orders uint32 `protobuf:"varint,1,opt,name=orders,proto3" json:"orders" yaml:"orders"`
}

func (m *BidEngineStatus) Reset()         { *m = BidEngineStatus{} }
func (m *BidEngineStatus) String() string { return proto.CompactTextString(m) }
func (*BidEngineStatus) ProtoMessage()    {}
func (*BidEngineStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ba712d181b7fc9b, []int{6}
}
func (m *BidEngineStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BidEngineStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BidEngineStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BidEngineStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BidEngineStatus.Merge(m, src)
}
func (m *BidEngineStatus) XXX_Size() int {
	return m.Size()
}
func (m *BidEngineStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_BidEngineStatus.DiscardUnknown(m)
}

var xxx_messageInfo_BidEngineStatus proto.InternalMessageInfo

func (m *BidEngineStatus) GetOrders() uint32 {
	if m != nil {
		return m.Orders
	}
	return 0
}

// ManifestStatus
type ManifestStatus struct {
	Deployments uint32 `protobuf:"varint,1,opt,name=deployments,proto3" json:"deployments" yaml:"deployments"`
}

func (m *ManifestStatus) Reset()         { *m = ManifestStatus{} }
func (m *ManifestStatus) String() string { return proto.CompactTextString(m) }
func (*ManifestStatus) ProtoMessage()    {}
func (*ManifestStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ba712d181b7fc9b, []int{7}
}
func (m *ManifestStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ManifestStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ManifestStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ManifestStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ManifestStatus.Merge(m, src)
}
func (m *ManifestStatus) XXX_Size() int {
	return m.Size()
}
func (m *ManifestStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ManifestStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ManifestStatus proto.InternalMessageInfo

func (m *ManifestStatus) GetDeployments() uint32 {
	if m != nil {
		return m.Deployments
	}
	return 0
}

// Status
type Status struct {
	Errors          []string         `protobuf:"bytes,1,rep,name=errors,proto3" json:"errors,omitempty" yaml:"errors,omitempty"`
	Cluster         *ClusterStatus   `protobuf:"bytes,2,opt,name=cluster,proto3" json:"cluster,omitempty" yaml:"cluster,omitempty"`
	BidEngine       *BidEngineStatus `protobuf:"bytes,3,opt,name=bid_engine,json=bidEngine,proto3" json:"bid_engine,omitempty" yaml:"bid_engine,omitempty"`
	Manifest        *ManifestStatus  `protobuf:"bytes,4,opt,name=manifest,proto3" json:"manifest,omitempty" yaml:"manifest,omitempty"`
	PublicHostnames []string         `protobuf:"bytes,5,rep,name=public_hostnames,json=publicHostnames,proto3" json:"public_hostnames" yaml:"public_hostnames"`
}

func (m *Status) Reset()         { *m = Status{} }
func (m *Status) String() string { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()    {}
func (*Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_1ba712d181b7fc9b, []int{8}
}
func (m *Status) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Status.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Status.Merge(m, src)
}
func (m *Status) XXX_Size() int {
	return m.Size()
}
func (m *Status) XXX_DiscardUnknown() {
	xxx_messageInfo_Status.DiscardUnknown(m)
}

var xxx_messageInfo_Status proto.InternalMessageInfo

func (m *Status) GetErrors() []string {
	if m != nil {
		return m.Errors
	}
	return nil
}

func (m *Status) GetCluster() *ClusterStatus {
	if m != nil {
		return m.Cluster
	}
	return nil
}

func (m *Status) GetBidEngine() *BidEngineStatus {
	if m != nil {
		return m.BidEngine
	}
	return nil
}

func (m *Status) GetManifest() *ManifestStatus {
	if m != nil {
		return m.Manifest
	}
	return nil
}

func (m *Status) GetPublicHostnames() []string {
	if m != nil {
		return m.PublicHostnames
	}
	return nil
}

func init() {
	proto.RegisterType((*ResourcesMetric)(nil), "akash.provider.v1.ResourcesMetric")
	proto.RegisterMapType((Storage)(nil), "akash.provider.v1.ResourcesMetric.StorageEntry")
	proto.RegisterType((*Leases)(nil), "akash.provider.v1.Leases")
	proto.RegisterType((*ReservationsMetric)(nil), "akash.provider.v1.ReservationsMetric")
	proto.RegisterType((*Reservations)(nil), "akash.provider.v1.Reservations")
	proto.RegisterType((*Inventory)(nil), "akash.provider.v1.Inventory")
	proto.RegisterType((*ClusterStatus)(nil), "akash.provider.v1.ClusterStatus")
	proto.RegisterType((*BidEngineStatus)(nil), "akash.provider.v1.BidEngineStatus")
	proto.RegisterType((*ManifestStatus)(nil), "akash.provider.v1.ManifestStatus")
	proto.RegisterType((*Status)(nil), "akash.provider.v1.Status")
}

func init() { proto.RegisterFile("akash/provider/v1/status.proto", fileDescriptor_1ba712d181b7fc9b) }

var fileDescriptor_1ba712d181b7fc9b = []byte{
	// 1087 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0xcf, 0x6b, 0x1b, 0x47,
	0x14, 0xf6, 0x46, 0xb6, 0x14, 0x8d, 0xed, 0x58, 0x9e, 0x06, 0xaa, 0x38, 0x41, 0xe3, 0x0e, 0x04,
	0x1c, 0x08, 0xbb, 0xc4, 0x09, 0xc5, 0x4d, 0x09, 0xb4, 0xeb, 0x18, 0x27, 0x50, 0x53, 0x67, 0x42,
	0x7a, 0x28, 0x05, 0xb3, 0x92, 0xa6, 0xab, 0x8d, 0xb4, 0x3f, 0xba, 0x3f, 0x04, 0x82, 0x52, 0x4a,
	0xaf, 0xbd, 0xf4, 0xaf, 0xe8, 0xa1, 0x7f, 0x47, 0x0f, 0x3e, 0xe6, 0x58, 0x28, 0x9d, 0x16, 0xf9,
	0x50, 0xaa, 0xa3, 0x7a, 0xeb, 0xa9, 0xcc, 0xce, 0xdb, 0x5f, 0xb2, 0x20, 0xc4, 0xb7, 0x9d, 0xf7,
	0xcd, 0x7c, 0xdf, 0xf7, 0xe6, 0xbd, 0x99, 0x59, 0xd4, 0xb1, 0x86, 0x56, 0x34, 0x30, 0x82, 0xd0,
	0x1f, 0x3b, 0x7d, 0x1e, 0x1a, 0xe3, 0x07, 0x46, 0x14, 0x5b, 0x71, 0x12, 0xe9, 0x41, 0xe8, 0xc7,
	0x3e, 0xde, 0x4e, 0x71, 0x3d, 0xc3, 0xf5, 0xf1, 0x83, 0x9d, 0x9b, 0xb6, 0x6f, 0xfb, 0x29, 0x6a,
	0xc8, 0x2f, 0x35, 0x71, 0x67, 0x57, 0x11, 0x39, 0xde, 0x98, 0x7b, 0xb1, 0x1f, 0x4e, 0x24, 0x53,
	0x6f, 0x94, 0x44, 0x31, 0x0f, 0x61, 0xc6, 0xa3, 0xe1, 0x41, 0x64, 0x38, 0xbe, 0x61, 0x05, 0x8e,
	0x6b, 0xf5, 0x06, 0x8e, 0xc7, 0xc3, 0x89, 0x11, 0x0c, 0x6d, 0x19, 0x30, 0x42, 0x1e, 0xf9, 0x49,
	0xd8, 0xe3, 0x86, 0xcd, 0x3d, 0x1e, 0x5a, 0x31, 0xef, 0xab, 0x55, 0xf4, 0x9f, 0x35, 0xb4, 0xc5,
	0x00, 0x8c, 0x4e, 0x78, 0x1c, 0x3a, 0x3d, 0xdc, 0x45, 0xb5, 0x5e, 0x90, 0xb4, 0xb5, 0x5d, 0x6d,
	0x6f, 0x7d, 0x5f, 0xd7, 0x87, 0x07, 0x91, 0xee, 0xf8, 0x7a, 0x99, 0x57, 0x0f, 0x86, 0xb6, 0x0c,
	0xe8, 0x19, 0xaf, 0xfe, 0x22, 0xb1, 0xbc, 0xd8, 0x89, 0x27, 0xe6, 0xee, 0xb9, 0x20, 0xda, 0x54,
	0x90, 0xda, 0xe1, 0xe9, 0xab, 0x99, 0x20, 0x92, 0x69, 0x2e, 0x08, 0x9a, 0x58, 0xee, 0xe8, 0x31,
	0xed, 0x05, 0x09, 0x65, 0x32, 0x84, 0xbf, 0x41, 0x75, 0x97, 0xbb, 0x7e, 0x38, 0x69, 0x5f, 0xbb,
	0x92, 0xcc, 0x3d, 0x90, 0xa9, 0x9f, 0xa4, 0x2c, 0x33, 0x41, 0x80, 0x6f, 0x2e, 0xc8, 0xa6, 0x12,
	0x53, 0x63, 0xca, 0x00, 0xc0, 0xaf, 0x51, 0xcd, 0x0e, 0x92, 0x76, 0xed, 0x4a, 0x7a, 0x7b, 0x59,
	0x5a, 0xc7, 0x2a, 0x2d, 0xbb, 0x9c, 0x96, 0x1d, 0x24, 0xf4, 0x97, 0x3f, 0xc9, 0xea, 0xf1, 0xe9,
	0xab, 0x88, 0x49, 0x08, 0xff, 0xac, 0xa1, 0x6d, 0x1e, 0x0c, 0xb8, 0xcb, 0x43, 0x6b, 0x74, 0x16,
	0xc5, 0x7e, 0x68, 0xd9, 0xbc, 0xbd, 0x7a, 0x25, 0xe9, 0xe7, 0x20, 0xdd, 0x3a, 0xca, 0x08, 0x5f,
	0x2a, 0xbe, 0x99, 0x20, 0x97, 0x45, 0xe6, 0x82, 0xb4, 0x95, 0xab, 0x4b, 0x10, 0x65, 0x2d, 0xbe,
	0x40, 0x81, 0xbf, 0x43, 0x8d, 0xcc, 0xdd, 0xda, 0x6e, 0x6d, 0x6f, 0x7d, 0xdf, 0xd0, 0x2f, 0xb5,
	0xa4, 0xbe, 0xd0, 0x20, 0x3a, 0x2c, 0x3e, 0xf2, 0xe2, 0x70, 0x62, 0x3e, 0x9c, 0x0a, 0xd2, 0x28,
	0x1c, 0x35, 0x0a, 0x1f, 0x37, 0x94, 0x8f, 0x4c, 0xfd, 0xbf, 0x62, 0x1e, 0xcb, 0x66, 0xed, 0xbc,
	0x46, 0x1b, 0x65, 0x36, 0xdc, 0x42, 0xb5, 0x21, 0x9f, 0xa4, 0xbd, 0xd7, 0x64, 0xf2, 0x13, 0x3f,
	0x45, 0x6b, 0x63, 0x6b, 0x94, 0xf0, 0xab, 0x35, 0x0a, 0x53, 0x8b, 0x1f, 0x5f, 0x3b, 0xd0, 0xe8,
	0x31, 0xaa, 0x7f, 0xc6, 0xad, 0x88, 0x47, 0xf8, 0x09, 0xaa, 0x5b, 0xbd, 0xd8, 0x19, 0xf3, 0x54,
	0x68, 0xd3, 0xbc, 0x2b, 0x3b, 0xe9, 0xd3, 0x34, 0x22, 0x3b, 0x49, 0x61, 0x45, 0x27, 0xa9, 0x31,
	0x65, 0x00, 0xd0, 0x5f, 0x35, 0x84, 0x19, 0x8f, 0x78, 0x38, 0xb6, 0x62, 0xc7, 0xf7, 0xb2, 0x73,
	0x73, 0x80, 0xd6, 0x7a, 0x7e, 0xe2, 0xc5, 0x40, 0x4a, 0xa7, 0x82, 0xac, 0x1d, 0xca, 0xc0, 0x4c,
	0x10, 0x85, 0xcc, 0x05, 0xd9, 0x80, 0x93, 0x20, 0x87, 0x94, 0xa9, 0x30, 0x8e, 0x51, 0x33, 0x73,
	0x1e, 0x41, 0x9e, 0xf4, 0xed, 0x75, 0x30, 0xf7, 0xcf, 0x05, 0x59, 0x99, 0x0a, 0xd2, 0xcc, 0x81,
	0x99, 0x20, 0x05, 0xd3, 0x5c, 0x90, 0x96, 0x52, 0xcb, 0x43, 0x94, 0x15, 0x30, 0xfd, 0x5b, 0x43,
	0x1b, 0xe5, 0x34, 0xb0, 0x8b, 0x1a, 0x01, 0xf7, 0xfa, 0x8e, 0x67, 0xc3, 0xe1, 0xbf, 0xbb, 0xdc,
	0xc4, 0x42, 0xe2, 0xe6, 0x7d, 0xf0, 0xd1, 0x38, 0x55, 0xab, 0x65, 0x1b, 0x00, 0x51, 0xd1, 0x06,
	0x10, 0xa0, 0x2c, 0x83, 0xf0, 0x20, 0xaf, 0xc2, 0xb5, 0x77, 0x51, 0xbb, 0x07, 0x6a, 0xef, 0x50,
	0xb0, 0x7f, 0x35, 0xd4, 0x7c, 0x9e, 0x5d, 0x9d, 0xb8, 0x87, 0x1a, 0x70, 0x75, 0x42, 0x9a, 0xb7,
	0x41, 0x38, 0xbf, 0x5d, 0xa5, 0xf2, 0xa1, 0x9a, 0x52, 0x24, 0x07, 0x01, 0x99, 0x1c, 0x2c, 0x2f,
	0x92, 0x83, 0x00, 0x65, 0x19, 0x84, 0xbf, 0xd7, 0xd0, 0x46, 0x58, 0x32, 0x0f, 0x39, 0x92, 0xb7,
	0xe4, 0x68, 0x7e, 0x0c, 0x72, 0x95, 0xca, 0xcc, 0x04, 0xa9, 0x90, 0xcd, 0x05, 0x79, 0x2f, 0xaf,
	0x6c, 0x1e, 0xa5, 0xac, 0x32, 0x89, 0xfe, 0xa1, 0xa1, 0x4d, 0x30, 0xfd, 0x32, 0x7d, 0x74, 0xf0,
	0x57, 0xa8, 0x3e, 0x4a, 0x4f, 0x00, 0x24, 0x7e, 0x6b, 0x89, 0x1b, 0x75, 0x44, 0x8a, 0x5d, 0x56,
	0x63, 0xb9, 0xcb, 0x6a, 0x69, 0xb1, 0xcb, 0x6a, 0x4c, 0x19, 0x00, 0xd8, 0x43, 0xcd, 0x7c, 0x07,
	0x21, 0xdd, 0x3b, 0x4b, 0x04, 0xf2, 0x42, 0x14, 0xfd, 0x9b, 0x87, 0x64, 0xff, 0xe6, 0x1c, 0x45,
	0xff, 0xe6, 0x21, 0xca, 0x0a, 0x98, 0x9e, 0xa2, 0x2d, 0xd3, 0xe9, 0x1f, 0x79, 0xb6, 0xe3, 0x71,
	0x48, 0xf0, 0x09, 0xaa, 0xfb, 0x61, 0x9f, 0x87, 0x51, 0xf9, 0x60, 0x7f, 0x9e, 0x46, 0x64, 0x06,
	0x0a, 0x2b, 0x32, 0x50, 0x63, 0xca, 0x00, 0xa0, 0x03, 0x74, 0xe3, 0xc4, 0xf2, 0x9c, 0xaf, 0x79,
	0x14, 0x03, 0xe1, 0x17, 0x68, 0xbd, 0xcf, 0x83, 0x91, 0x3f, 0x71, 0xb9, 0x17, 0x67, 0xac, 0x8f,
	0xa6, 0x82, 0xac, 0x3f, 0x2d, 0xc2, 0x33, 0x41, 0xca, 0xb3, 0xe6, 0x82, 0x60, 0xc5, 0x5f, 0x0a,
	0x52, 0x56, 0x9e, 0x42, 0x7f, 0x5f, 0x45, 0x75, 0x90, 0x78, 0x81, 0xea, 0x3c, 0x0c, 0xfd, 0xd4,
	0x73, 0x6d, 0xaf, 0x69, 0x7e, 0x24, 0x3d, 0x1f, 0xa5, 0x91, 0x99, 0x20, 0x2d, 0x85, 0xdd, 0xf7,
	0x5d, 0x27, 0xe6, 0x6e, 0x10, 0xcb, 0x5d, 0x79, 0x1f, 0x2e, 0xf8, 0x05, 0x84, 0x32, 0x20, 0xc2,
	0xdf, 0x16, 0x1d, 0xae, 0xea, 0xb0, 0xbb, 0xa4, 0x0e, 0x95, 0xd6, 0x30, 0x3f, 0x81, 0x57, 0xa6,
	0xd4, 0xe6, 0xdb, 0xc0, 0x51, 0xd1, 0x6e, 0x57, 0x1a, 0xbe, 0x2c, 0x9e, 0xb7, 0xfe, 0x8f, 0x1a,
	0x42, 0x5d, 0xa7, 0x7f, 0xc6, 0xd3, 0xca, 0xc0, 0x83, 0xbb, 0xec, 0x3e, 0x5b, 0xa8, 0x9e, 0xf9,
	0x0c, 0x3c, 0x34, 0x73, 0x60, 0x26, 0xc8, 0xcd, 0x82, 0xaa, 0x62, 0xe4, 0xb6, 0x32, 0xb2, 0x0c,
	0xa5, 0xac, 0xd9, 0xcd, 0x18, 0xf0, 0x0f, 0x1a, 0xba, 0xee, 0x42, 0x51, 0xe1, 0x05, 0xfe, 0x60,
	0x89, 0x97, 0x6a, 0xdd, 0xcd, 0x43, 0xb0, 0x72, 0x3d, 0x8b, 0xcf, 0x04, 0xc1, 0x19, 0x4d, 0xc5,
	0xc7, 0x2d, 0xf8, 0xdb, 0xb8, 0x84, 0x51, 0x96, 0xeb, 0x62, 0x17, 0xb5, 0x82, 0xa4, 0x3b, 0x72,
	0x7a, 0x67, 0x03, 0x3f, 0x8a, 0x3d, 0xcb, 0xe5, 0x51, 0xfa, 0xde, 0x36, 0x4d, 0x73, 0x2a, 0xc8,
	0xd6, 0x69, 0x8a, 0x3d, 0xcb, 0x20, 0x59, 0xf6, 0xc5, 0xe9, 0x45, 0xd9, 0x17, 0x11, 0xca, 0xb6,
	0x82, 0xea, 0x7a, 0xf3, 0xc3, 0xf3, 0x69, 0x47, 0x7b, 0x33, 0xed, 0x68, 0x7f, 0x4d, 0x3b, 0xda,
	0x4f, 0x17, 0x9d, 0x95, 0x37, 0x17, 0x9d, 0x95, 0xdf, 0x2e, 0x3a, 0x2b, 0x5f, 0xde, 0xb1, 0x7d,
	0x95, 0x7c, 0x5f, 0x77, 0x7c, 0x23, 0xea, 0x0f, 0xcb, 0xff, 0xa6, 0xdd, 0x7a, 0xfa, 0x53, 0xf8,
	0xf0, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xfa, 0x69, 0x6d, 0x22, 0xb7, 0x0a, 0x00, 0x00,
}

func (m *ResourcesMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourcesMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourcesMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Storage) > 0 {
		for k := range m.Storage {
			v := m.Storage[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintStatus(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintStatus(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintStatus(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.EphemeralStorage != nil {
		{
			size, err := m.EphemeralStorage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.GPU != nil {
		{
			size, err := m.GPU.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Memory != nil {
		{
			size, err := m.Memory.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CPU != nil {
		{
			size, err := m.CPU.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Leases) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Leases) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Leases) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Active != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.Active))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReservationsMetric) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReservationsMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReservationsMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Resources.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Count != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Reservations) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Reservations) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Reservations) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Active.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Pending.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Inventory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Inventory) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Inventory) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Reservations.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Cluster.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ClusterStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Inventory.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Leases.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStatus(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BidEngineStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BidEngineStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BidEngineStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Orders != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.Orders))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ManifestStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ManifestStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ManifestStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Deployments != 0 {
		i = encodeVarintStatus(dAtA, i, uint64(m.Deployments))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Status) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PublicHostnames) > 0 {
		for iNdEx := len(m.PublicHostnames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PublicHostnames[iNdEx])
			copy(dAtA[i:], m.PublicHostnames[iNdEx])
			i = encodeVarintStatus(dAtA, i, uint64(len(m.PublicHostnames[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Manifest != nil {
		{
			size, err := m.Manifest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.BidEngine != nil {
		{
			size, err := m.BidEngine.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Cluster != nil {
		{
			size, err := m.Cluster.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStatus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Errors) > 0 {
		for iNdEx := len(m.Errors) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Errors[iNdEx])
			copy(dAtA[i:], m.Errors[iNdEx])
			i = encodeVarintStatus(dAtA, i, uint64(len(m.Errors[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintStatus(dAtA []byte, offset int, v uint64) int {
	offset -= sovStatus(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ResourcesMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CPU != nil {
		l = m.CPU.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.Memory != nil {
		l = m.Memory.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.GPU != nil {
		l = m.GPU.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.EphemeralStorage != nil {
		l = m.EphemeralStorage.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	if len(m.Storage) > 0 {
		for k, v := range m.Storage {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovStatus(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovStatus(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovStatus(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Leases) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Active != 0 {
		n += 1 + sovStatus(uint64(m.Active))
	}
	return n
}

func (m *ReservationsMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovStatus(uint64(m.Count))
	}
	l = m.Resources.Size()
	n += 1 + l + sovStatus(uint64(l))
	return n
}

func (m *Reservations) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pending.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.Active.Size()
	n += 1 + l + sovStatus(uint64(l))
	return n
}

func (m *Inventory) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Cluster.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.Reservations.Size()
	n += 1 + l + sovStatus(uint64(l))
	return n
}

func (m *ClusterStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Leases.Size()
	n += 1 + l + sovStatus(uint64(l))
	l = m.Inventory.Size()
	n += 1 + l + sovStatus(uint64(l))
	return n
}

func (m *BidEngineStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Orders != 0 {
		n += 1 + sovStatus(uint64(m.Orders))
	}
	return n
}

func (m *ManifestStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Deployments != 0 {
		n += 1 + sovStatus(uint64(m.Deployments))
	}
	return n
}

func (m *Status) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Errors) > 0 {
		for _, s := range m.Errors {
			l = len(s)
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	if m.Cluster != nil {
		l = m.Cluster.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.BidEngine != nil {
		l = m.BidEngine.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	if m.Manifest != nil {
		l = m.Manifest.Size()
		n += 1 + l + sovStatus(uint64(l))
	}
	if len(m.PublicHostnames) > 0 {
		for _, s := range m.PublicHostnames {
			l = len(s)
			n += 1 + l + sovStatus(uint64(l))
		}
	}
	return n
}

func sovStatus(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozStatus(x uint64) (n int) {
	return sovStatus(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ResourcesMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourcesMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourcesMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CPU", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CPU == nil {
				m.CPU = &resource.Quantity{}
			}
			if err := m.CPU.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Memory == nil {
				m.Memory = &resource.Quantity{}
			}
			if err := m.Memory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GPU", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GPU == nil {
				m.GPU = &resource.Quantity{}
			}
			if err := m.GPU.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EphemeralStorage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EphemeralStorage == nil {
				m.EphemeralStorage = &resource.Quantity{}
			}
			if err := m.EphemeralStorage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Storage == nil {
				m.Storage = make(Storage)
			}
			var mapkey string
			var mapvalue *resource.Quantity
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthStatus
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthStatus
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthStatus
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthStatus
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &resource.Quantity{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipStatus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthStatus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Storage[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Leases) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Leases: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Leases: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			m.Active = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Active |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReservationsMetric) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReservationsMetric: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReservationsMetric: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Reservations) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reservations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reservations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pending", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pending.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Active.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Inventory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Inventory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Inventory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Cluster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reservations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Reservations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leases", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Leases.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inventory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Inventory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BidEngineStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BidEngineStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BidEngineStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orders", wireType)
			}
			m.Orders = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Orders |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ManifestStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ManifestStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ManifestStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deployments", wireType)
			}
			m.Deployments = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Deployments |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cluster == nil {
				m.Cluster = &ClusterStatus{}
			}
			if err := m.Cluster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BidEngine", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BidEngine == nil {
				m.BidEngine = &BidEngineStatus{}
			}
			if err := m.BidEngine.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manifest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Manifest == nil {
				m.Manifest = &ManifestStatus{}
			}
			if err := m.Manifest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicHostnames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStatus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicHostnames = append(m.PublicHostnames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStatus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStatus(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStatus
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStatus
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthStatus
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupStatus
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthStatus
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthStatus        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStatus          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupStatus = fmt.Errorf("proto: unexpected end of group")
)
